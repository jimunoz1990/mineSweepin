var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

import PropTypes from 'prop-types';
import { shallow as enzymeShallow } from 'enzyme';
import createRenderer from './createRenderer';
import { renderToString } from 'fela-tools';
import cssbeautify from 'cssbeautify';
import toJson from 'enzyme-to-json';
import { variables as themeConstants } from 'cf-style-const'; // eslint-disable-line behance/no-deprecated
import { createTheme, THEME_CHANNEL } from 'fela-bindings';
import { ThemeProvider } from 'cf-style-container';

var mergeOptions = function mergeOptions(options, renderer, theme) {
  var _childContextTypes, _contextTypes;

  return _extends({
    childContextTypes: (_childContextTypes = {}, _defineProperty(_childContextTypes, THEME_CHANNEL, PropTypes.object), _defineProperty(_childContextTypes, 'renderer', PropTypes.object), _childContextTypes),
    contextTypes: (_contextTypes = {}, _defineProperty(_contextTypes, THEME_CHANNEL, PropTypes.object), _defineProperty(_contextTypes, 'renderer', PropTypes.object), _contextTypes),
    context: _defineProperty({
      renderer: renderer
    }, THEME_CHANNEL, theme ? createTheme(theme) : createTheme(themeConstants))
  }, options);
};

var shallow = function shallow(node) {
  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

  var rootRenderer = createRenderer({
    dev: true
  });

  var wrapper = enzymeShallow(node, mergeOptions(options, rootRenderer));

  //if we are dealing with a fela node, or a ThemeProvider then dive until we get to a non-fela node (for rendering)
  var dive = function dive(wrapper, renderer) {
    var theme = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;

    var reactElement = wrapper.get(0);

    //if the element in question is a ThemeProvider, use its theme and pass it down
    //the tree in context
    if (reactElement && reactElement.type === ThemeProvider) {
      theme = reactElement.props.theme;
    }

    if (reactElement && reactElement.type && (reactElement.type._isFelaComponent || reactElement.type === ThemeProvider)) {
      var mergedOptions = mergeOptions(options, renderer, theme);
      return dive(wrapper.dive(mergedOptions), renderer, theme);
    }
    return wrapper;
  };

  var componentSnapshot = function componentSnapshot(wrapper) {
    var options = {
      indent: '  ',
      openbrace: 'end-of-line',
      autosemicolon: false
    };

    var renderer = rootRenderer;
    var wrapperToSnapshot = wrapper;

    var reactElement = wrapper.get(0);

    //if the element being snapshot is a fela component or a ThemeProvider
    //we need to dive into it and keep shallow rendering. for this we will use
    if (reactElement && reactElement.type && (reactElement.type._isFelaComponent || reactElement.type === ThemeProvider)) {
      //use a new renderer to capture the styles just by rendering this enzyme wrapper
      renderer = createRenderer({
        dev: true
      });
      wrapperToSnapshot = dive(wrapper, renderer);
    }

    return {
      component: toJson(wrapperToSnapshot),
      styles: '\n' + cssbeautify(renderToString(renderer), options) + '\n'
    };
  };

  //if the enzyme wrapper is around a single node, returns an object with keys: component, style
  //otherwise returns an array where each element in the array is an object with keys: component, style
  //where the snapshot for that element is stored.
  var snapshot = function snapshot(enzymeWrapper) {
    if (enzymeWrapper.length === 1) {
      return componentSnapshot(enzymeWrapper);
    }
    return enzymeWrapper.map(function (wrapper) {
      return componentSnapshot(wrapper);
    });
  };

  return {
    wrapper: wrapper,
    snapshot: snapshot
  };
};

export default shallow;